"""
test_lines.py

Test that fluorescence line distributions work.

27 April 2017
Joe Fowler
"""

import pytest
from pytest import approx
import numpy as np
import mass
import pylab as plt


class Test_MnKA_distribution:
    @staticmethod
    def test_for_negative_energies():
        """Check that no negative energies are generated by a fluorescence line
        distribution. This tests for issue #112.
        """
        line = mass.calibration.fluorescence_lines.MnKAlpha
        values = line.rvs(size=100000, instrument_gaussian_fwhm=0)
        assert 0 < values.min()

        # This seed definitely caused errors at the time of issue #112.
        # But numpy has changed since, so this might be a meaningless test
        rng = np.random.default_rng(134)
        values = line.rvs(size=100000, instrument_gaussian_fwhm=0, rng=rng)
        assert 0 < values.min()

    @staticmethod
    def test_quartiles():
        """Check that the quartiles of the generated energies are reasonable."""
        line = mass.calibration.fluorescence_lines.MnKAlpha
        print(line.__dict__)
        values = line.rvs(size=100000, instrument_gaussian_fwhm=0)
        quartiles = np.percentile(values, [25, 50, 75])
        assert quartiles[0] == approx(5888.3, abs=1)
        assert quartiles[1] == approx(5896.9, abs=10)
        assert quartiles[2] == approx(5899, abs=1)

    @staticmethod
    def test_plot_like_reference():
        line = mass.spectra["MnKAlpha"]
        line.plot_like_reference()
        plt.close()

    @staticmethod
    def test_location_against_STANDARD_FEATUES():
        for (name, spectrum) in mass.spectra.items():
            if spectrum.reference_short in {"NIST ASD", "Clementson 2010", "Nilsen 1995"}:
                continue
            if not spectrum.is_default_material:
                continue
            if "KBeta24" in name:
                continue
            target = mass.STANDARD_FEATURES[name]
            result = np.abs(spectrum.nominal_peak_energy - target) < 0.5
            if not result:
                print(f"{name} spectrum.nominal_peak_energy={spectrum.nominal_peak_energy}, mass.STANDARD_FEATURES={target}, abs diff={np.abs(spectrum.nominal_peak_energy - target)}")
            assert result

            # test that basic funtionality works for all instances
            v = spectrum.rvs(1, instrument_gaussian_fwhm=0)
            v = spectrum(spectrum.peak_energy, instrument_gaussian_fwhm=0)
            assert v is not None
            assert spectrum.reference
            # check that normalize intensities sum to 1
            assert spectrum.normalized_lorentzian_integral_intensity.sum() == approx(1)


class TestAddFitter:
    @staticmethod
    def test_add_same_line_fails():
        def addline_example(replace=False):
            mass.calibration.fluorescence_lines.addline(
                element="dummy",
                linetype="KBeta",
                material="dummy_material",
                reference_short='NIST ASD',
                fitter_type=mass.GenericLineModel,
                reference_plot_instrument_gaussian_fwhm=0.5,
                nominal_peak_energy=(653.679946 * 2 + 653.493657 * 1) / 3,
                energies=np.array([653.493657, 653.679946]), lorentzian_fwhm=np.array([0.1, 0.1]),
                allow_replacement=replace,
                reference_amplitude=np.array([1, 2]),
                reference_amplitude_type=mass.LORENTZIAN_PEAK_HEIGHT, ka12_energy_diff=None
            )
        addline_example()
        # It should be okay to re-add the dummyKBeta line if but only if replace=True.
        addline_example(replace=True)
        with pytest.raises(ValueError):
            addline_example()

        # test various ways I can get access to the new line
        mass.spectra["dummyKBeta"].model()
        mass.spectra["dummyKBeta"].model(has_tails=True)
        mass.spectra["dummyKBeta"].fitter()
        mass.spectrum_classes["dummyKBeta"]().model()
        mass.make_line_fitter(mass.spectra["dummyKBeta"])

    @staticmethod
    def test_intrinsic_sigma():
        line = mass.calibration.fluorescence_lines.MnKAlpha
        e = np.linspace(5880, 5910, 31)
        y1 = line(e, instrument_gaussian_fwhm=0)
        y2 = line(e, instrument_gaussian_fwhm=8)
        line.intrinsic_sigma = 8 / 2.3548
        y3 = line(e, instrument_gaussian_fwhm=0)
        maxdiff = np.abs(y1 - y2).max()
        assert maxdiff > 1e-4, "Setting resolution=8 eV should change line"
        maxdiff = np.abs(y1 - y3).max()
        assert maxdiff > 1e-4, "Setting instrinsic_sigma to 3.40 eV should change line"
        maxdiff = np.abs(y2 - y3).max()
        assert maxdiff < 1e-5, "Setting resolution=8 eV or intrinsic_sigma=3.40 eV should be equivalent"
        line.intrinsic_sigma = 0.0

    @staticmethod
    def test_some_lines_make_sense():
        assert mass.spectra["MnKAlpha"].nominal_peak_energy == 5898.802
        assert mass.spectra["AuLAlpha"].nominal_peak_energy == 9713.44


class TestFitterBehavior:
    @staticmethod
    def test_fitter_disallows_weights():
        "Make sure that it's an exception to pass weights (other than None) to model.fit"
        line = mass.calibration.fluorescence_lines.MnKAlpha
        model = line.model()
        Nbins = 100
        e = np.linspace(5800, 5920, Nbins)
        sim = np.random.default_rng(2934).poisson(lam=20, size=Nbins)
        params = model.guess(sim, bin_centers=e, dph_de=1)
        model.fit(sim, params, bin_centers=e, weights=None)
        with pytest.raises(Exception):
            model.fit(sim, params, bin_centers=e, weights=sim**1.5)
